/**
 * For some unexpected reasons it can happen that the translations in Crowdin are lost.
 * If that happens, we can rebuild the Crowdin translations file from our translated json file.
 *
 * This script is used to rebuild the translations file from the empty skeleton file generated by Crowdin.
 */

import fs from 'fs';
import path from 'path';

import yargs from 'yargs';

// Get our args
const argv = yargs(process.argv).argv;
const { app, output, language } = argv;

const folderPath = './locales/' + app;
const namefile = 'translations-skeleton.json';
const nameRebuildfile = 'translations-rebuild.json';

const pathRebuildFile = path.join(folderPath, path.sep, nameRebuildfile);

// Get the skeleton generated from crowdin
const pathSkeletonFile = path.join(folderPath, path.sep, namefile);

if (!fs.existsSync(pathSkeletonFile)) {
  throw new Error(`File ${pathSkeletonFile} not found!`);
}

// Get the translated file
if (!fs.existsSync(output)) {
  throw new Error(`File ${output} not found!`);
}

const jsonSkel = JSON.parse(fs.readFileSync(pathSkeletonFile, 'utf8'));
const jsonTrans = JSON.parse(fs.readFileSync(output, 'utf8'));

// Transform the json file to the format expected by i18next
const jsonRebuild = { ...jsonSkel };
Object.keys(jsonSkel)
  .sort()
  .forEach((key) => {
    const path = key.split('.');
    console.log(path);
    const message = path.reduce((acc, curr) => acc[curr] || '', jsonTrans[language]['translation']);
    console.log(message)
    jsonRebuild[key]['message'] = message || '';
    jsonRebuild[key]['description'] = jsonSkel[key]['description'] || '';
  });

// Write the file to the output
fs.writeFileSync(pathRebuildFile, JSON.stringify(jsonRebuild), 'utf8');

console.log(`${app} translations rebuild!`);
